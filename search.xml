<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于</title>
      <link href="//about/"/>
      <url>//about/</url>
      
        <content type="html"><![CDATA[<p>欢迎光临来到本小站~</p><p>这里是细粒丁の个人博客哦~</p><hr><h2 id="先介绍下自己吧"><a href="#先介绍下自己吧" class="headerlink" title="先介绍下自己吧~"></a>先介绍下自己吧~</h2><p>这里细粒丁，坐标广东广州，是个男孩纸~</p><p>昂有很多个名字哦，嗯…有… 细粒丁、来自火星の细粒丁、女娲&amp;兔兔</p><p>关于我的称呼还挺多的，比如：细粒丁、粒粒、丁丁、兔兔 ……</p><p>至于为什么嘛。。。呃…本兔也不知道呢！</p><h3 id="技术方面嘛"><a href="#技术方面嘛" class="headerlink" title="技术方面嘛"></a>技术方面嘛</h3><p>目前还是个小白了啦~<br>玩前端比较多，之前玩的小程序，然后就玩了会儿uni-app（Vue），现在就搞搞博客这样咯~</p><hr><h2 id="再说说这个博客"><a href="#再说说这个博客" class="headerlink" title="再说说这个博客"></a>再说说这个博客</h2><p>建个人博客是从我刚学前端没多久，就想做的一件事了啦，因为自己有个炫酷的网站真的好像挺帅气的。</p><p>当时刚开始接触三件套，就想着 要不就建一个静态的吧，把内容都写死在html里不就好了，当时真的挺天真的~</p><p>后来到了暑期，玩了小程序之后，技术有个小阶梯的飞跃吧，后面再学Vue还是挺容易的，然后就想，要不建个动态的吧，就用Vue！这也就是这个博客的初态。</p><p>我大概已经构思好了怎么用Vue来搭建了，然后在我做完两三个页面之后，发现问题了……虽然说动态是好，完整搭出来可能和做一个完整小程序差不多，但…真的有这个必要吗？一个博客最多就是像个朋友圈一样，能实时展示最新的消息，但好像没这个必要：</p><ol><li>首先是时效性。博客只是像单纯的写文章、写日记、做笔记差不多，并不需要很高的时效性，有些内容迟一天发和早一天发，甚至可以说没影响</li><li>资源问题。如果用Vue，从前端-云开发（云函数+云数据库），前端可以挂静态托管，但后端的资源消耗会很大。我做过小程序，如果所有服务都通过云函数调用获取，资源都存储在云存储和云数据库中，这个每天或是每个月的消耗还是挺大的，最起码免费的不够用。</li><li>管理问题。动态的可以说使用方便，但需要有人去管理，管理的成本也不少，一旦说哪一环出现问题了，都要自己去维护，对于我一个学生党来说挺花时间的。相反静态就不怎么需要维护了，放着就好了……</li></ol><p>所以就想到了用hexo，直接打包成静态的发布，维护小、成本低…….就它了！</p><hr><h2 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h2><h4 id="2021-7-19"><a href="#2021-7-19" class="headerlink" title="2021-7-19"></a>2021-7-19</h4><ol><li>本站的大致结构基本形成，并发布在了github的个人主页上进行测试</li><li>本站采用的是hexo框架-butterfly主题</li><li>本站设置了评论系统，可邮箱通知最新消息</li><li>设置了贡献面板</li><li>不知道了啦……太多了……</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现TCP/IP连接</title>
      <link href="/%E6%8A%80%E6%9C%AF/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0TCPIP%E8%BF%9E%E6%8E%A5/"/>
      <url>/%E6%8A%80%E6%9C%AF/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0TCPIP%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言实现TCP-IP连接"><a href="#C语言实现TCP-IP连接" class="headerlink" title="C语言实现TCP/IP连接"></a>C语言实现TCP/IP连接</h1><p>利用C语言，实现TCP/IP连接。其中采用CS模式+套接字的方式。    </p><p>先上代码：</p><h3 id="Server-c-服务端"><a href="#Server-c-服务端" class="headerlink" title="Server.c    服务端"></a>Server.c    服务端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字连接--全局</span></span><br><span class="line"><span class="keyword">int</span> client;</span><br><span class="line"><span class="comment">// 调用socket函数返回的文件描述符</span></span><br><span class="line"><span class="keyword">int</span> serverSocket;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">200</span>]; <span class="comment">//存储 发送和接收的信息</span></span><br><span class="line"><span class="keyword">int</span> iDataNum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端，等待客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">监听后，一直处于accept阻塞状态，</span></span><br><span class="line"><span class="comment">直到有客户端连接，</span></span><br><span class="line"><span class="comment">当客户端如数quit后，断开与客户端的连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明两个套接字sockaddr_in结构体变量，分别表示客户端和服务器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须先初始化</span></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;require version fail!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//socket函数，失败返回-1</span></span><br><span class="line"><span class="comment">//int socket(int domain, int type, int protocol);</span></span><br><span class="line"><span class="comment">//第一个参数表示使用的地址类型，一般都是ipv4，AF_INET</span></span><br><span class="line"><span class="comment">//第二个参数表示套接字类型：tcp：面向连接的稳定数据传输SOCK_STREAM</span></span><br><span class="line"><span class="comment">//第三个参数设置为0</span></span><br><span class="line"><span class="comment">//建立socket</span></span><br><span class="line"><span class="keyword">if</span> ((serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 server_addr</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务器端的套接字，并用htons和htonl将端口和地址转成网络字节序</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ip可是是本服务器的ip，也可以用宏INADDR_ANY代替，代表0.0.0.0，表明所有地址</span></span><br><span class="line">server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于bind，accept之类的函数，里面套接字参数都是需要强制转换成(struct sockaddr *)</span></span><br><span class="line"><span class="comment">//bind三个参数：服务器端的套接字的文件描述符，</span></span><br><span class="line"><span class="keyword">if</span> (bind(serverSocket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务器上的socket为监听状态</span></span><br><span class="line"><span class="keyword">if</span> (listen(serverSocket, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n监听端口: %d\n&quot;</span>, SERVER_PORT);</span><br><span class="line"><span class="comment">//调用accept函数后，会进入阻塞状态</span></span><br><span class="line"><span class="comment">//accept返回一个套接字的文件描述符，这样服务器端便有两个套接字的文件描述符，</span></span><br><span class="line"><span class="comment">//serverSocket和client。</span></span><br><span class="line"><span class="comment">//serverSocket仍然继续在监听状态，client则负责接收和发送数据</span></span><br><span class="line"><span class="comment">//clientAddr是一个传出参数，accept返回时，传出客户端的地址和端口号</span></span><br><span class="line"><span class="comment">//addr_len是一个传入-传出参数，传入的是调用者提供的缓冲区的clientAddr的长度，以避免缓冲区溢出。</span></span><br><span class="line"><span class="comment">//传出的是客户端地址结构体的实际长度。</span></span><br><span class="line"><span class="comment">//出错返回-1</span></span><br><span class="line">client = accept(serverSocket, (struct sockaddr *)&amp;clientAddr, (<span class="keyword">socklen_t</span> *)&amp;addr_len);</span><br><span class="line"><span class="keyword">if</span> (client &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inet_ntoa ip地址转换函数，将网络字节序IP转换为点分十进制IP</span></span><br><span class="line"><span class="comment">// 表达式：char *inet_ntoa (struct in_addr);</span></span><br><span class="line"><span class="comment">// printf(&quot;IP is %s\n&quot;, inet_ntoa(clientAddr.sin_addr)); //把来访问的客户端的IP地址打出来</span></span><br><span class="line"><span class="comment">// printf(&quot;Port is %d\n\n&quot;, htons(clientAddr.sin_port));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;host: %s:%d\n\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), htons(clientAddr.sin_port));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待信息...\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">iDataNum = recv(client, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iDataNum &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">buffer[iDataNum] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到的信息：%s\n\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信息</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入发送的内容：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;buffer);</span><br><span class="line">        send(client, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>); <span class="comment">//向服务端发送消息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockInit();</span><br><span class="line">get_msg();</span><br><span class="line">getchar();</span><br><span class="line">close(serverSocket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Client-c-客户端"><a href="#Client-c-客户端" class="headerlink" title="Client.c    客户端"></a>Client.c    客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字连接--全局</span></span><br><span class="line"><span class="comment">// 客户端只需要一个套接字文件描述符，用于和服务器通信</span></span><br><span class="line"><span class="keyword">int</span> serverSocket;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">200</span>]; <span class="comment">//存储 发送的信息</span></span><br><span class="line"><span class="keyword">int</span> iDataNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述服务器的socket</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面代码初始化</span></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;require version fail!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定服务器端的ip，本地测试：127.0.0.1</span></span><br><span class="line"><span class="comment">//inet_addr()函数，将点分十进制IP转换成网络字节序IP</span></span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connect(serverSocket, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sockInit() != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n连接成功...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送信息</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入发送的内容：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;buffer);</span><br><span class="line">        send(serverSocket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>); <span class="comment">//向服务端发送消息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待信息...\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">iDataNum = recv(serverSocket, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iDataNum &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">buffer[iDataNum] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;收到的信息：%s\n\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">close(serverSocket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，send()是用来发送数据的，recv()是用来接收数据的</p><p><strong>接收数据</strong>的时候，通常情况下是不知道大小的，所以使用的是缓冲区的大小<em>sizeof(buffer)</em></p><p>但在<strong>发送数据</strong>的时候，是可以知道数据的长度/大小的，所以可以直接用*strlen(buffer)*来获取和确定要发送的长度</p><p>注：直接在cmd用gcc编译时，记得加上 -lwsock32    (当前是Windows 10)</p><p><code>$ gcc .\Server.c -o .\Server.exe -lwsock32</code></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>还有一点需要注意的是，我试过：先写好客户端只发送数据，服务端只接收数据</p><p>然后利用Client端 连续不间断地向Server端发送长度较大的数据，这时在Server端打印接收到的数据时，往往会显示（接收）不完全，或许是recv()中的数据并没有被完全读进buffer中去。</p><p>怎么说呢，就像是我Server端要接收一大串的数据，我这一大串(来自recv的)数据还没有读到尾(‘\0’) 内存还没读完，buffer就要被拿去printf了，printf完就被填充全0，准备下一次的数据接收。</p><p>那怎么办呢，要确保Server端完整读取发送过来的数据呀，那我加延时呗 等内存读完呗，延时完再打印和初始化buffer。</p><p>实验结果发现，确实可以，但！这个延时加在Server端却没用，对于Server端来说 每一条语句执行的顺序都是一样的，速度也是相当的，你不可能说加了个延时它就不接收数据了呀，对吧。</p><p>然后我把延时加在了Client端发送那里，确保每次发送都有一段不会太短的时间间隔，这样Server端就能完整读取完数据再处理下一次的接收。</p><p>真是非常的amazing啊，当初我还是搞网安玩加密的时候试出来的，调了半天，以为是因为加密后乱码 发过去了读不出来，结果才发现可能是内存没读完导致的，郁闷了两天（托腮.jpg）</p><p>不过这也只不过是我猜测的啦，真正具体是什么原因导致读不完我还不怎么清楚了啦……(蹲个大佬 我插个眼)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C </tag>
            
            <tag> TCP </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS闭包异步问题</title>
      <link href="/%E6%8A%80%E6%9C%AF/JS%E9%97%AD%E5%8C%85%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/%E6%8A%80%E6%9C%AF/JS%E9%97%AD%E5%8C%85%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JS闭包异步问题"><a href="#JS闭包异步问题" class="headerlink" title="JS闭包异步问题"></a>JS闭包异步问题</h1><p>假设我们现在想要先执行f2，执行完f2之后在紧跟执行f1。我们应该这样写：👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;this is f1&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;this is f2&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">     callback()</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start time:&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">f2(f1)</span><br></pre></td></tr></table></figure><p>这样他会先打印”start time”，过两秒后打印”f2”的时间，再过2s后再打印”f1”</p><p><img src="image-20210713003026939.png" alt="image-20210713003026939"></p><img src="image-20210713003317016.png" alt="image-20210713003317016"  /><hr><p>若换一种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;this is f1&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;this is f2&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start time:&quot;</span>,<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">f2()</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>这样并不能达到异步的效果，它会先打印”start time”，之后在接下来的语句中，它会执行f2()、f1() ，f1打印的时间应该和f2打印的时间是一样的</p><p>解释：这里f1的执行，并不需要等待f2执行完 跳出来之后再执行，这里就像是解析语句一般，解析完“要执行f2()”，之后解析“要执行f1()”，它两之间就几个微秒的间隔</p><p><img src="image-20210713004030715.png" alt="image-20210713004030715"></p><hr><div class="mermaid">sequenceDiagramNote over 主 线: 解析&quot;start time&quot;Note over 主 线: 解析f2()主 线-&gt;&gt;+支线1: 给我去执行f2()Note over 支线1: 执行f2()Note over 主 线: 解析f1()主 线-&gt;&gt;+支线2: 给我去执行f1()Note over 支线2: 执行f1()</div><ol><li><p>主线先解析”start time”</p></li><li><p>主线解析“要执行f2()”，然后把f2的具体内容交给支线1去执行，支线1与主线互不干扰，两者并行</p></li><li><p>主线解析“要执行f1()”，然后把f1的具体内容交给支线2去执行，支线2与主线互不干扰，两者并行</p><p>（与此同时，支线1继续执行f2的内容，理论上应该还没执行完f2  因为主线从解析f2()到解析f1()仅需大概6微秒左右[视芯片而定吧]）</p></li></ol><p>这里用 <code>new Date().getTime()</code> 打印了时间戳，</p><p>“start time” 与f2 相差 2012ms，也就是2s + 12ms</p><p>f2和f1的时间就差了1ms</p><p><img src="image-20210713010648477.png" alt="image-20210713010648477"></p><hr><p>若直接用 <code>new Date().getMilliseconds()</code> 打印ms：</p><p><img src="image-20210713011331809.png" alt="image-20210713011331809"><img src="image-20210713011353347.png" alt="image-20210713011353347"></p><p>大概就是看进位吧？！</p><p>反正就是两者的间隔时间很短，并不会出现执行完f2()在执行f1()的情况</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
